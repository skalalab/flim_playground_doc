# Lifetime Features (Fit)

Biological samples often contain mixtures of fluorescent species, each with its own characteristic lifetime. By modeling the decay as a sum of exponentials, the analysis can separate and quantify these different contributions. For example, NADH in cells exists in both free (short lifetime, ~0.4 ns) and protein-bound (longer lifetime, ~2â€“3 ns) states; by fitting the fluorescence decay with a bi-exponential model, one can estimate the fraction of each state, which provides direct insight into cellular metabolism and energy production pathways. 

FLIM Playground extracts cell-level lifetime fitting features in this feature extractor, including the fraction of each lifetime component ($\alpha_i$), their lifetimes ($\tau_i$), and mean lifetime ($\tau_{mean}$). 

$$I(t) = \sum_i \alpha_i \, e^{-t/\tau_i}$$

## Fitting 

If the decays have not been pre-fitted, FLIM Playground will use the confirmed fitting options ([number of components](numerical_feature_extraction.qmd#number-of-components), [time gates](numerical_feature_extraction.qmd#time-gates), [metric](numerical_feature_extraction.qmd#metric), and [fitting mode](numerical_feature_extraction.qmd#fitting-mode)) and the same [reconvolution fitting process](numerical_feature_extraction.qmd#reconvolution-fitting) as the [irf shift calibration step](numerical_feature_extraction.qmd#fit-calibration) to fit the decay curves, with the only difference being that the IRF shift is no longer a free variable to be optimized. To recap, the reconvolution fitting takes into account of the IRF, and minimizing the custom objective function will fit the decay curve with a multi-exponential model. 

[Otherwise](#pixel-prefitted), FLIM Playground will use the [pre-fitted values](data_extraction.qmd#spcimage-t1) to calculate the fitting features. 

Fitting features in the final dataset will have the prefix set to be the combination of the feature extractor name (i.e. `Lifetime fit`) and the channel name, allowing [Data Analysis](data_analysis.qmd) to group the features. For example, `Lifetime fit_nadh: a1` means the fraction of the first lifetime component for the NAD(P)H channel. 

### Preprocessing 

It sums up all the pixel decays belonging to the same cell ROI labeled by the ROI [mask](data_extraction.qmd#mask) as one decay curve [@samimi25]. The ROI summing reduces variability and bias and allows for short integration times at acquisition in exchange for sub-cellular granularity. Also, it makes FLIM Playground, a single thread Python app running on CPU, possible to fit curves in a reasonable time. 

It also shifts the IRF using the shift values from the [IRF shift Calibration](numerical_feature_extraction.qmd#fit-calibration) step. To shift an IRF, FLIM Playground upsamples the IRF 10 times and uses linear interpolation to fill the gaps. Then it shifts the IRF by the shift values $\times 10$ and downsamples the IRF back to the original size. 

### Fraction of components

In addition to the absolute amplitudes of each component directly from the fitting result, FLIM Playground calculates the fraction of each component, $\alpha_i$, as the amplitude of the component divided by the sum of all amplitudes. This normalization allows lifetime to be independent of the absolute intensity of the signal. 

### Mean lifetime

The mean lifetime, $\tau_{mean}$, is calculated as the weighted average of the lifetimes of all components, where the weights are the fractions of each component. 

$$\tau_{mean} = \sum_{i=1}^n \alpha_i \tau_i$$

## Pixel-prefitted
Currently, FLIM Playground supports pixel-prefitted lifetime features from [SPCImage](https://www.becker-hickl.com/products/spcimage/). The pixel-level lifetime fitting features are expected to be stored in [2D arrays](data_extraction.qmd#spcimage-t1) in spatial dimensions, with each row and column has the value of a lifetime feature outputted from SPCImage. SPCImage will output `0` for pixels that are not fitted (e.g. thresholded out). To avoid those pixels that bias the results, FLIM Playground uses `np.ma.masked_array` to mask the pixels that are not fitted. 

Then it uses the ROI [mask](data_extraction.qmd#mask) to calculate the cell-level lifetime features by averaging the pixel-level features within each ROI. 