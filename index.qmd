<style>
.quarto-title-block {
  display: none;
}
.quarto-title {
  display: none;
}
</style>

![](logo.gif){width=300px fig-align="center"}

# Quick Start

Welcome to the FLIM Playground ðŸ¥³ðŸŽ‰ðŸ¥‚! It is an interactive graphical user interface (GUI) that allows you to extract single cell features from FLIM raw data ([Data Extraction](data_extraction.qmd)) and analyze extracted features or datasets extracted yourself using a built-in repertoire of methods ([Data Analysis](data_analysis.qmd)). 

To quickly try out different analysis methods, download this [sample dataset] and try the [online demo](https://flim-playground.streamlit.app/). If you prefer to use your own data, read [data analysis configuration](data_analysis_config.qmd) to learn how to configure the system.

![](analysis_ui_shots/feature_comparison.png){width=100% fig-align=center}

Due to the online limitation, extracting features from raw data is not available in the demo. Read on to learn more about the system, including how to [download](#download) and use the desktop app, from processing raw decay data to gaining insights.

# Installation

The system is built entirely in Python and is open-source. 

## Download
Download the desktop app from [GitHub](https://github.com/skalalab/flim_playground) and double click it to run. Releases are available for Windows 11 and Mac OS 15. If your operating system is not either of these, you can build it yourself by following the instructions below.

## Build it yourself
1. Clone the repo and navigate into the repository once cloned.

2. Install the python environment
    - Install uv if not yet installed
    - run `uv sync`
3. Build the app
    - run `pyinstaller Flim-Playground.spec --clean`

# Introduction

Fluorescence lifetime imaging microscopy (FLIM) measures the time it takes for a fluorescent molecule from being excited by a pulse of light (entering excited state) to emitting light (returning to the ground state). It is sensitive to changes in fluorophore microenvironment including conformational changes with protein binding and the presence of quenchers. Coupled with modern automated cell-segmentation methods [@stringer2021], FLIM enables single-cell analyses that reveal biological heterogeneity.

::: {.callout-note collapse="true"}
# Instrumentation

To acquire FLIM data, a light sourceâ€”typically a pulsed laser for time-domain methods or a modulated continuous-wave source for frequency-domain methodsâ€”is used to excite the fluorophore. The emission is detected using instrumentation capable of resolving fluorescence decay, such as time-correlated single-photon counting (TCSPC), time-gated detectors, or phase/modulation-based detection. In time-domain FLIM, the delay between excitation and photon arrival is measured, and often a histogram is built, with x-axis being the delay time and y-axis being the number of photons falling into each time bin. Similar to film (e.g., 24 frames per second) versus photo, FLIM has an additional dimension of time (e.g., 256 time bins per 12.5 nanoseconds) compared to intensity images. 

In frequency-domain FLIM, the phase shift and modulation depth of the emission relative to the excitation are determined. 
:::

However, due to the [challenges](#challenges), researchers often rely on a patchwork of ad hoc scripts and specialized software. However, switching between methods or transitioning between stages usually requires coding expertise, introduces errors, and slows discovery. 

# Challenges
A diverse set of [tools](https://www.phasorpy.org/docs/stable/phasor_approach/#software) â€” both open-source and commercial, ranging from libraries to code-free graphical user interfaces (GUIs) â€” are available to extract and analyze FLIM data, providing alternative methods and therefore flexibility. For example, [PhasorPy](https://www.phasorpy.org/) [@phasorpy25] is a Python library that provides a set of functions to extract pixel-level phasor features and to analyze fluorescence lifetime using the phasor approach. [SPCImage](https://www.becker-hickl.com/products/spcimage/) is a commercial software that provides an user interface to extract pixel-level fitted and phasor features. 

However, the user needs to write custom code to either (1) use the tools, or (2) perform <span style="color: #ff7f0e;">cell-level</span>, <span style="color: #2ca02c;">channel-level</span> , <span style="color: #d62728;">field-of-view-level</span>, or <span style="color: #9467bd;">experiment-level</span> extraction and analysis from the <span style="color: #1f77b4;">pixel-level</span> outputs of such tools. 

## Levels of Data

- <span style="color: #1f77b4;">**Pixel**</span>
- <span style="color: #ff7f0e;">**Region of Interest (ROI)**</span>
  - Whole cell mask
  - Cytoplasm mask
  - Nucleus mask
  - Stain mask, etc. 
- <span style="color: #2ca02c;">**Channel**</span>
  - Different fluorophores
  - Different calibration files
  - Different ROI masks
- <span style="color: #d62728;">**Field of View (FOV)**</span>
  - different file formats from various vendors (e.g., `.sdt`, `.ptu`)
  - different dimensions (e.g., `YT`, `YXT`, `CYXT`)
- <span style="color: #9467bd;">**Experiment**</span>
  - different treatment, different time points, different conditions, etc., and combinations thereof

An integrated framework should take into account all data levels <span style="color: #1f77b4;">â– </span> <span style="color: #ff7f0e;">â– </span> <span style="color: #2ca02c;">â– </span> <span style="color: #d62728;">â– </span> <span style="color: #9467bd;">â– </span> (â€¢) while maintaining the flexibility to handle the various input types (â—¦) available. **It should provide a level of abstraction to address fragmentation from input types**.

Also, FLIM is a rapidly evolving field, and new methods are being developed all the time. An integrated framework should provide allow users to choose among alternative methods seemlessly and be ready to incorporate new methods: **a level of abstraction to address fragmentation from extraction and analysis methods**. 

Finally, many of the tools especially GUI softwares are not cross-platform, which limits the accessibility of the tools. The [Installation](#installation) addresses this last challenge.

# Solution

## Abstraction Level

Inspired by the [data levels](#levels-of-data), tabular data columns can be categorized into three sets:

- identifiers: unique row identifier (<span style="color: #ff7f0e;">â– </span>) and (optional) field of view identifier (<span style="color: #d62728;">â– </span>)
- categorical features: conceptually help us group the rows (e.g., `treatment` will group the rows into different treatment groups) (<span style="color: #ff7f0e;">â– </span> <span style="color: #9467bd;">â– </span>)
- numerical features: quantify the differences/similarities between data groups (<span style="color: #ff7f0e;">â– </span> <span style="color: #2ca02c;">â– </span>)

**Science, from the data perspective, is about closing the conceptual categorical gaps with quantitative measurements.**

## Design
FLIM Playground has two independent sections:

INSERT FIGURE HERE (FIGURE 2)

### Data Extraction

[Data Extraction](data_extraction.qmd) extracts single-cell features from the raw data. It adopts a [framework](#data_extraction_config.qmd#channel-centric-framework) that offers channel-level flexibility in input types and extraction methods without incurring too much overhead for the user. Following the above categorization, it is divided into the following steps:

- [Data Extraction Configuration](data_extraction_config.qmd): allows users to choose among alternative input types and extraction methods (extractors).
- [Metadata organization](fov_metadata.qmd): extracts the field of view identifiers and their configurations
- [Numerical Feature Extraction](numerical_feature_extraction.qmd): extracts single-cell numerical features by user-selected extractors. More extractors can be integrated in the future.
  - [Calibration](numerical_feature_extraction.qmd#calibration): calibrate for IRF shift or use reference dye
  - alternative lifetime extractors: 
    - [Fitting](lifetime_fit.qmd)
    - [Phasor](lifetime_fit_free.qmd)
  - alternative intensity-based extractors:
    - [Morphology](intensity_morphology.qmd)
    - [Texture](intensity_texture.qmd)
- [Categorical feature extraction](categorical_feature_extraction.qmd): extracts single-cell categorical features and combines experiment-level datasets.

### Data Analysis

[Data Analysis](data_analysis.qmd) analyzes featuresâ€”whether extracted through Data Extraction or by other methodsâ€”using visualizations and statistical modeling. It deploys a [shared framework](#data_analysis.qmd#shared-interactive-widgets) built to handle the [three sets of features](#abstraction-level) across all analysis methods, enabling the same interactive and frictionless exploration experience. 

- [Data Analysis](data_analysis.qmd) goes in-depth in how FLIM Playground handles the three sets of features and [Data Analysis Config](data_analysis_config.qmd) goes through how users can configure FLIM Playground to analyze datasets that are not extracted by [Data Extraction](data_extraction.qmd). 

Here is the list of analysis methods, grouped by the number of numerical features they take as input:

- [Univariate analysis](data_analysis.qmd#univariate-analysis)
  - [Feature Comparison](feature_comparison.qmd)
  - [Feature Histogram](feature_histogram.qmd)
  - [Field of View Comparison](fov_comparison.qmd)
- [Bivariate analysis](data_analysis.qmd#bivariate-analysis)
  - [Feature Distribution](feature_distribution.qmd)
- [Multivariate analysis](data_analysis.qmd#multivariate-analysis)
  - [Dimension Reduction](dimension_reduction.qmd)
  - [Classification](classification.qmd)

New methods can be integrated in the future easily, building on the [shared framework](#data_analysis.qmd#shared-interactive-widgets).

## Summary

**FLIM Playground** removes these hurdles with an interactive code-free graphical user interface (GUI) that spans the full pipeline. It integrates validation checks that guide users at every step, and built-in repertoire of analytical methods with interactive widgets that encourage hypothesis driven, iterative exploration of large datasets. A modular architecture also enables incorporation of new algorithms.