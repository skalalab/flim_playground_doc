# Lifetime Features (Fit-Free) {#sec-lifetime-fit-free}

Phasor analysis provides a fast, model-free view of lifetimes by transforming fluorescence decays into phasor coordinates through a Fourier transform. This approach is considered “fit-free” because it does not require iterative curve fitting or predefined decay models—each decay is mapped directly to a point on the [phasor plot](phasor_analysis.qmd). It has the nice property that mono-exponential decays fall on the universal semicircle while mixtures lie inside as linear combinations, so clusters reveal distinct species and their fractional contributions. FLIM Playground currently extracts cell-level phasor features: `g`, `s`, `Tau_phase`, `Tau_m`, `g_2nd` (2nd harmonic), and `s_2nd`. 

Fit-free features in the final dataset are prefixed by the combination of the feature extractor name (i.e. `Lifetime fit free`) and the channel name, allowing [Data Analysis](data_analysis.qmd) to group the features. For example, `Lifetime fit free_nadh: G` means the $g$ coordinate for this cell in the NAD(P)H channel. 

## Preprocessing

It sums up all the pixel decays belonging to the same cell ROI labeled by the ROI [mask](data_extraction.qmd#mask) as one decay curve [@Samimi2025]. The phasor features are calculated from the summed decay curve. 

If the chosen [calibration method](data_extraction_config.qmd#calibration-method) is IRF shift calibration, FLIM Playground shifts the IRF using the shift values and subtracts the estimated offset as described in the [IRF shift calibration step](numerical_feature_extraction.qmd#irf-shift). 

## Phasor features

### Step 1: raw phasor coordinates

The reference implementation from [phasorpy](https://www.phasorpy.org/) assumes the decay curve comes from one period and time bins are evenly spaced (Untruncated). So their calculation is frequency ($f$) and time ($T$) independent. But there are cases when the decay curve is truncated due to the deadtime of the system. For example, when the laser frequency is $f = 0.08$ GHz, the theoretical period is $T = 12.5$ ns, but in practice the time window is truncated to $T = 10$ ns. FLIM Playground applies custom implementation to the truncated decay curve. (the `sample_phase` option can be used to account for the truncation but it does not handle the second or above harmonics)

#### Untruncated decay curve

It uses the [`phasor_from_signal`](https://www.phasorpy.org/docs/stable/api/phasor/#phasorpy.phasor.phasor_from_signal) function from the [phasorpy](https://www.phasorpy.org/) package to calculate the uncalibrated phasor coordinates `g_raw` and `s_raw`, `g_raw_2nd` and `s_raw_2nd`, the first and second harmonics' real and imaginary parts, from the cell decay curve.

Either `g_irf`, `s_irf`, `g_irf_2nd`, and `s_irf_2nd` from the IRF, or `ref_mean`, `ref_real`, `ref_imag` from the reference dye, depending on the chosen [calibration method](data_extraction_config.qmd#calibration-method), are calculated using the same function.

Mathematically, the raw phasor coordinates are calculated as (copied from the [phasorpy](https://www.phasorpy.org/docs/stable/api/phasor/#phasorpy.phasor.phasor_from_signal) documentation):

$$
F_{\mathrm{DC}}=\frac{1}{K}\sum_{k=0}^{K-1}F_k,\quad
g_{\mathrm{raw}}=\frac{1}{F_{\mathrm{DC}}}\frac{1}{K}\sum_{k=0}^{K-1}F_k\cos\!\left(2\pi h \frac{k}{K}\right),\quad
s_{\mathrm{raw}}=\frac{1}{F_{\mathrm{DC}}}\frac{1}{K}\sum_{k=0}^{K-1}F_k\sin\!\left(2\pi h \frac{k}{K}\right)
$$
where $K$ is the number of time bins, $F_k$ is the decay curve, and $h$ is the harmonic number.

#### Truncated decay curve

The phasor coordinates of IRF and the decay curves of both harmonics are calculated using time axis $t_k = k\,(T/K)\;\;(k=0,\ldots,K-1)$ and angular frequency $\omega = 2\pi\,hf$:

$$
g_{\mathrm{raw}}
=\frac{\sum_{k=0}^{K-1} F_k \cos\!\big(\omega\, t_k\big)}
        {\sum_{k=0}^{K-1} F_k},\quad
s_{\mathrm{raw}}
=\frac{\sum_{k=0}^{K-1} F_k \sin\!\big(\omega\, t_k\big)}
        {\sum_{k=0}^{K-1} F_k}
$$

This formula is equivalent to the untruncated formula when $fT = 1$.

For reference dye, the phasor coordinates are calculated using `phasorpy`'s `phasor_from_signal` and `sample_phase` option is set to $\omega t_k$.

### Step 2: calibrated phasor coordinates

To get the calibrated phasor coordinates `g`, `s`, `g_2nd`, and `s_2nd`, FLIM Playground uses either
```python
from phasorpy import phasor
g, s = phasor.phasor_divide(g_raw, s_raw, g_irf, s_irf)
g_2nd, s_2nd = phasor.phasor_divide(g_raw_2nd, s_raw_2nd, g_irf_2nd, s_irf_2nd)
```
or 
```python
from phasorpy import lifetime
g, s = lifetime.phasor_calibrate(g_raw, s_raw, ref_mean, ref_real, ref_imag, frequency=laser_rate, lifetime=reference_dye_lifetime)
g_2nd, s_2nd = lifetime.phasor_calibrate(g_raw_2nd, s_raw_2nd, ref_mean, ref_real, ref_imag, frequency=laser_rate, lifetime=reference_dye_lifetime, harmonic=2)
```

The `laser_rate` is specified during the [fov metadata extraction](fov_metadata.qmd#laser-frequency) and [config](data_extraction_config.qmd#laser-frequency). 

### Step 3: phasor-derived lifetime

`Tau_phase` and `Tau_m` are calculated using the first harmonic's phasor coordinates `g` and `s`. 

```python
import numpy as np
w = 2 * np.pi * laser_rate
phi = np.arctan2(s, g) 
m = np.sqrt(g**2 + s**2)
tau_phase = 1/w * np.tan(phi)
tau_m = 1/w * np.sqrt(1/m**2 - 1)
```

$$
\phi = \operatorname{atan2}(s,\,g), m = \sqrt{g^{2}+s^{2}}, \tau_{\phi} = \frac{\tan \phi}{\omega}, \tau_{M} = \frac{1}{\omega}\sqrt{\frac{1}{m^{2}}-1}
$$
